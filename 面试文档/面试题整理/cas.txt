concurrent   并发
 atomin  原子性,  读法aotumeike


volatile:

volatile的理解
	1volatile是Java虚拟机提供的轻量级同步机制(轻量的意思是低配)
		1.1保证可见性
			当一个线程修改了这个变量的值，volatile 保证了新值能立即同步到主内存，以及每次使用前立即从主内存刷新。
			但普通变量做不到这点，普通变量的值在线程间传递均需要通过主内存（详见：Java内存模型）来完成
		1.2不保证原子性
			操作可以被打断
		1.3禁止指令重排
			
volatile 性能：
　　volatile 的读性能消耗与普通变量几乎相同，但是写操作稍慢，因为它需要在本地代码中插入许多内存屏障指令来保证处理器不发生乱序执行

jmm(java内存模型):本身是一种抽象的概念并不真实存在,它描述的是一组规则或规范,
通过这组规范定义了程序中各个变量(包括实例字段,静态字段和 构成数组对象的元素)的访问方式.

主内存和工作内存的理解
由于及运行的程序都是线程,而每个线程创建时 , jvm都会为其创建一个工作内存(栈空间)  , 工作内存	是每个线程的私有数据区域,而java内存模型规定所有变量都在主内存,主内存是共享区域,所有线程都可以访问
但线程对变量的操作必须在自己的工作内存中,首先将变量拷贝到自己的工作内存空间,然后对变量进行操作,操作完成在写回主内存,不可以直接操作主内存中变量



内存模型三大特性: 可见性,原子性 有序性
可见性:  只要有一个线程修改了自己的工作空间的值并且写回到主内存以后要及时通知其他线程,这个及时通知的情况俗称可见性

当一个线程对变量进行操作还没有写回主内存时两一个变量去操作了未被写回的主内存中的共享变量,这种工作内存和主内存之间的延迟现象造成了可见性

原子性:不可分割,完整性,可就是说耨个线程在进行某个具体业务是,中间不可以被打断,要么同时成功,要么同时失败.

解决volative不保证原子性的问题,我们可以使用juc包下的atomic类来保证原子性,比如atomicInteger


禁止指令重排:计算机在执行程序时,为了提高性能,编译器和处理器会对指令进行重排序

源代码->编译器优化的重排->指令并行的重排->内存系统的重排->最终的执行指令

单线程程序确保程序最终执行结果和代码顺序的结果一致
多线程程序交替执行,由于指令重排序的存在,俩个线程使用的变量不一定保持一致性,结果无法预测

禁止指令重排的案例
单例模式在多线程情况下采用双端检索机制,这个正确性为百分之99.9
判断对象是否已经存在的语句要执行两次,在两次之间加一个synchronized锁
if(instance == null){
	synchronized(singletonDemo.class){
		if(instance == null)
			instance = new SingletonDemo();		
	}
}

为什么加锁还会导致错误?
和对象的初始化和对象分配内存地址的顺序有关,指令重排不能保证线程安全

解决方法----加入volative进行修饰
private static volatlie 类  instance(实现类);
正常的顺序是先初始化对象,然后再为其分配空间,可是多线程情况下可能出现先分配地址空间在进行初始化对象,在刚分配好空寂爱你还没有进行对象初始化时,别的线程引用这个空间的对象,,为空,就初始化了一个新的对象 ,造成线程安全问题











 
Cas:-------比较并交换---compareAndSet

Cas的全程compare-And-Swap
它的功能是判断内存某个位置的值是否为预期值,这个过程是原子的.
CAS并发原语体是java语言中Unsafe类的各个方法.
CAS是一种系统原语,原语的执行必须是连续的,在执行过程中不允许被打断,不会造成数据不一致问题

例如:AtomicInteger调用里面的compareAndSet(期望值 , 修改值) 方法
compareAndSet 方法的两个参数(期望值 , 更新值)
期望值必须和主内存里面的值相同,才可以写回主内存中

AtomicInteger a = new AtomicInteger(5);
a.compareAndSet(5,100);  true
a.compareAndSet(5,200);	 false
方法会返回一个boolean类型数据,存入主内存返回true

如果线程的期望值和物理内存的真实值一样,返回true,修改物理内存的值
如果线程的期望值和物理内存的真实值不一样,返回false,不可以修改物理内存的值

这个方法的底层里面有一个  
	public final int getAndIncrement(){
		return unsafe.getAndAddInt(this,valueoffset,1);
					三个参数为	当前对象,内存偏移量,常数
	}
 
内存偏移量通过unsafe.objectFieldoffset来获取


Unsafe 是Cas的核心类,由于Java方法无法直接访问底层,需要通过本地(native)方法来访问,
unsafe相当于一个后门,基于该类可以直接操作特定的内存数据,其内部方法操作可以像c的指针一样直接操作内存,
CAS操作的执行依赖于Unsafe

注意:Unsafe类中所有的方法都是native修饰的,也就是说Unsafe方法都直接调用调用操作系统底层资源执行相应任务

Cas保证原子性靠的是Unsafe类,Unsafe类来自jvm的rt.jar运行架包里面
Unsafe可以根据内存偏移地址获取数据

CAS自旋思想
先通过unsafe.objectFieldoffset获取内存偏移量,再通过unsafe.getAndIncrement()方法获取主内存值
getAndAddInt方法执行时,有个do  while
当获取的主内存的值与期望值不同时,重新循环获取主内存里面的值进行比较

AtomicInteger为什么使用CAS而不使用synchronized?
Synchronized加锁，同一时间段只允许一个线程进行访问，一致性得到保障但并发性下降。
CAS中调用的getAndAddInt方法中通过do while循环，可以反复通过比较直到比较成功修改值为止，即保证了一致性又提高了并发性。

CAS的缺点:  
	1底层的do while ,如果一直不同,会一直循环执行,开销大
	2当对一个变量操作时,可以通过循环cas的方式保证原子性,但是多个线程操作共享变量时,循环cas就无法保证原子性,这是可以用锁来保证
	3ABA问题
	
	
	
	
	
	

ABA问题--

	


	
